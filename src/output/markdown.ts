/**
 * ReachVet - Markdown Report Generator
 * 
 * Generates Markdown reports suitable for PR comments and documentation.
 */

import type { AnalysisOutput, ComponentResult, AnalysisSummary, ReachabilityStatus } from '../types.js';

// ============================================================
// Options
// ============================================================

export interface MarkdownOptions {
  /** Include component details table */
  includeDetails?: boolean;
  /** Include warnings section */
  includeWarnings?: boolean;
  /** Max components to show in details (default: 50) */
  maxComponents?: number;
  /** Show only vulnerable components */
  vulnerableOnly?: boolean;
  /** Include code locations */
  includeLocations?: boolean;
  /** Compact mode for PR comments */
  compact?: boolean;
}

// ============================================================
// Status Emoji Mapping
// ============================================================

const STATUS_EMOJI: Record<ReachabilityStatus, string> = {
  reachable: 'ğŸŸ¢',
  imported: 'ğŸŸ¡',
  not_reachable: 'âšª',
  indirect: 'ğŸ”µ',
  unknown: 'â“',
};

const SEVERITY_EMOJI: Record<string, string> = {
  critical: 'ğŸ”´',
  high: 'ğŸŸ ',
  medium: 'ğŸŸ¡',
  low: 'ğŸŸ¢',
  unknown: 'âšª',
};

// ============================================================
// Generator
// ============================================================

/**
 * Generate Markdown report from analysis output
 */
export function toMarkdown(output: AnalysisOutput, options: MarkdownOptions = {}): string {
  const {
    includeDetails = true,
    includeWarnings = true,
    maxComponents = 50,
    vulnerableOnly = false,
    includeLocations = false,
    compact = false,
  } = options;

  const lines: string[] = [];

  // Header
  if (!compact) {
    lines.push('# ReachVet Analysis Report');
    lines.push('');
    lines.push(`**Generated:** ${output.timestamp}`);
    lines.push(`**Source:** \`${output.sourceDir}\``);
    lines.push(`**Language:** ${output.language}`);
    lines.push('');
  }

  // Summary
  lines.push(compact ? '## Summary' : '## ğŸ“Š Summary');
  lines.push('');
  lines.push(generateSummaryTable(output.summary, compact));
  lines.push('');

  // Vulnerability Alert
  if (output.summary.vulnerableReachable > 0) {
    lines.push(compact ? '### âš ï¸ Vulnerable Dependencies Detected' : '## âš ï¸ Vulnerable Dependencies Detected');
    lines.push('');
    lines.push(generateVulnerabilityTable(output.results));
    lines.push('');
  }

  // Details
  if (includeDetails && !compact) {
    lines.push('## ğŸ“‹ Component Details');
    lines.push('');

    let filtered = output.results;
    if (vulnerableOnly) {
      filtered = filtered.filter((r) => r.component.vulnerabilities && r.component.vulnerabilities.length > 0);
    }

    if (filtered.length > maxComponents) {
      lines.push(`> Showing first ${maxComponents} of ${filtered.length} components`);
      lines.push('');
      filtered = filtered.slice(0, maxComponents);
    }

    lines.push(generateDetailsTable(filtered, includeLocations));
    lines.push('');
  }

  // Warnings
  if (includeWarnings && output.summary.warningsCount > 0) {
    lines.push(compact ? '### âš ï¸ Analysis Warnings' : '## âš ï¸ Analysis Warnings');
    lines.push('');
    lines.push(generateWarningsSection(output.results, compact));
    lines.push('');
  }

  // Footer
  if (!compact) {
    lines.push('---');
    lines.push(`*Generated by ReachVet v${output.version}*`);
  }

  return lines.join('\n');
}

/**
 * Generate summary table
 */
function generateSummaryTable(summary: AnalysisSummary, compact: boolean): string {
  if (compact) {
    return [
      `| Metric | Count |`,
      `|--------|-------|`,
      `| Total | ${summary.total} |`,
      `| Reachable ğŸŸ¢ | ${summary.reachable} |`,
      `| Imported ğŸŸ¡ | ${summary.imported} |`,
      `| Not Reachable âšª | ${summary.notReachable} |`,
      `| **Vulnerable & Reachable** | **${summary.vulnerableReachable}** |`,
    ].join('\n');
  }

  const reachablePercent = summary.total > 0 ? ((summary.reachable / summary.total) * 100).toFixed(1) : '0';
  const unusedPercent = summary.total > 0 ? ((summary.notReachable / summary.total) * 100).toFixed(1) : '0';

  return [
    `| Status | Count | Percentage |`,
    `|--------|-------|------------|`,
    `| ğŸŸ¢ Reachable | ${summary.reachable} | ${reachablePercent}% |`,
    `| ğŸŸ¡ Imported (usage unclear) | ${summary.imported} | ${summary.total > 0 ? ((summary.imported / summary.total) * 100).toFixed(1) : '0'}% |`,
    `| âšª Not Reachable | ${summary.notReachable} | ${unusedPercent}% |`,
    `| ğŸ”µ Indirect | ${summary.indirect} | ${summary.total > 0 ? ((summary.indirect / summary.total) * 100).toFixed(1) : '0'}% |`,
    `| â“ Unknown | ${summary.unknown} | ${summary.total > 0 ? ((summary.unknown / summary.total) * 100).toFixed(1) : '0'}% |`,
    `| **Total** | **${summary.total}** | 100% |`,
    ``,
    `| Metric | Value |`,
    `|--------|-------|`,
    `| ğŸ”´ Vulnerable & Reachable | **${summary.vulnerableReachable}** |`,
    `| âš ï¸ Analysis Warnings | ${summary.warningsCount} |`,
  ].join('\n');
}

/**
 * Generate vulnerability alert table
 */
function generateVulnerabilityTable(results: ComponentResult[]): string {
  const vulnerable = results.filter(
    (r) =>
      (r.status === 'reachable' || r.status === 'imported') &&
      r.component.vulnerabilities &&
      r.component.vulnerabilities.length > 0
  );

  if (vulnerable.length === 0) {
    return '_No vulnerable dependencies detected._';
  }

  const lines = [
    `| Component | Version | Status | Vulnerabilities | Severity |`,
    `|-----------|---------|--------|-----------------|----------|`,
  ];

  for (const result of vulnerable) {
    const vulns = result.component.vulnerabilities!;
    const vulnIds = vulns.map((v) => `\`${v.id}\``).join(', ');
    const maxSeverity = getMaxSeverity(vulns.map((v) => v.severity || 'unknown'));
    const emoji = SEVERITY_EMOJI[maxSeverity];

    lines.push(
      `| ${result.component.name} | ${result.component.version} | ${STATUS_EMOJI[result.status]} ${result.status} | ${vulnIds} | ${emoji} ${maxSeverity} |`
    );
  }

  return lines.join('\n');
}

/**
 * Generate component details table
 */
function generateDetailsTable(results: ComponentResult[], includeLocations: boolean): string {
  if (results.length === 0) {
    return '_No components to display._';
  }

  const lines = includeLocations
    ? [
        `| Component | Version | Status | Used Members | Locations |`,
        `|-----------|---------|--------|--------------|-----------|`,
      ]
    : [`| Component | Version | Status | Used Members |`, `|-----------|---------|--------|--------------|`];

  for (const result of results) {
    const usedMembers = result.usage?.usedMembers?.slice(0, 5).join(', ') || '-';
    const truncated = result.usage?.usedMembers && result.usage.usedMembers.length > 5 ? '...' : '';

    if (includeLocations) {
      const locations =
        result.usage?.locations
          ?.slice(0, 3)
          .map((l) => `\`${l.file}:${l.line}\``)
          .join(', ') || '-';
      lines.push(
        `| ${result.component.name} | ${result.component.version} | ${STATUS_EMOJI[result.status]} | ${usedMembers}${truncated} | ${locations} |`
      );
    } else {
      lines.push(
        `| ${result.component.name} | ${result.component.version} | ${STATUS_EMOJI[result.status]} | ${usedMembers}${truncated} |`
      );
    }
  }

  return lines.join('\n');
}

/**
 * Generate warnings section
 */
function generateWarningsSection(results: ComponentResult[], compact: boolean): string {
  const allWarnings: Array<{ component: string; code: string; message: string; location?: string }> = [];

  for (const result of results) {
    if (result.warnings) {
      for (const warning of result.warnings) {
        allWarnings.push({
          component: result.component.name,
          code: warning.code,
          message: warning.message,
          location: warning.location ? `${warning.location.file}:${warning.location.line}` : undefined,
        });
      }
    }
  }

  if (allWarnings.length === 0) {
    return '_No warnings._';
  }

  if (compact) {
    // Group by code for compact mode
    const grouped = new Map<string, number>();
    for (const w of allWarnings) {
      grouped.set(w.code, (grouped.get(w.code) || 0) + 1);
    }
    return Array.from(grouped.entries())
      .map(([code, count]) => `- **${code}**: ${count} occurrences`)
      .join('\n');
  }

  const lines = [`| Component | Warning | Location |`, `|-----------|---------|----------|`];

  const shown = allWarnings.slice(0, 20);
  for (const w of shown) {
    lines.push(`| ${w.component} | ${w.code}: ${w.message} | ${w.location || '-'} |`);
  }

  if (allWarnings.length > 20) {
    lines.push(`| ... | _${allWarnings.length - 20} more warnings_ | |`);
  }

  return lines.join('\n');
}

/**
 * Get maximum severity from a list
 */
function getMaxSeverity(severities: string[]): string {
  const order = ['critical', 'high', 'medium', 'low', 'unknown'];
  for (const level of order) {
    if (severities.includes(level)) {
      return level;
    }
  }
  return 'unknown';
}

/**
 * Generate a compact summary for PR comments
 */
export function toMarkdownSummary(output: AnalysisOutput): string {
  const { summary } = output;
  const hasVulnerable = summary.vulnerableReachable > 0;

  const statusIcon = hasVulnerable ? 'ğŸ”´' : summary.reachable > 0 ? 'ğŸŸ¢' : 'âšª';
  const headline = hasVulnerable
    ? `**${summary.vulnerableReachable} vulnerable dependencies are reachable!**`
    : `${summary.reachable} of ${summary.total} dependencies are reachable`;

  return [
    `### ${statusIcon} ReachVet Analysis`,
    '',
    headline,
    '',
    `- ğŸŸ¢ Reachable: ${summary.reachable}`,
    `- ğŸŸ¡ Imported: ${summary.imported}`,
    `- âšª Unused: ${summary.notReachable}`,
    hasVulnerable ? `- ğŸ”´ **Vulnerable & Reachable: ${summary.vulnerableReachable}**` : '',
  ]
    .filter(Boolean)
    .join('\n');
}
